# -*- coding: utf-8 -*-
"""m3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bL4iXp3-fkaiU4ZUy8LMYIQThDd0rnx_
"""

pip install numpy matplotlib tensorflow==2.0.0 tensorflow_datasets

"""Parts of this code are learned from: https://www.thepythoncode.com/article/image-classification-keras-python"""

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout, Activation, Flatten
from tensorflow.keras.layers import Conv2D, MaxPooling2D, AveragePooling2D
from tensorflow.keras.callbacks import TensorBoard
import tensorflow as tf
import tensorflow_datasets as tfds
import os

from tensorflow.keras.models import load_model
import matplotlib.pyplot as plt
import numpy as np

# Setting hyper-parameters
batch_size = 32
num_classes = 3
epochs = 3

"""## Loading and preparing the data"""

def load_data():
    """
    Loading rock_paper_scissors dataset and preprocessing it
    """
    def preprocess_image(image, label):
        # convert [0, 255] range integers to [0, 1] range floats
        image = tf.image.convert_image_dtype(image, tf.float32)
        return image, label

    # loading the dataset, split into train and test
    ds_train, info = tfds.load("rock_paper_scissors", with_info=True, split="train", as_supervised=True)
    ds_test = tfds.load("rock_paper_scissors", split="test", as_supervised=True)

    # repeat dataset forever, shuffle the images, preprocess the images, split by batch
    ds_train = ds_train.repeat().shuffle(1024).map(preprocess_image).batch(batch_size)
    ds_test = ds_test.repeat().shuffle(1024).map(preprocess_image).batch(batch_size)
    return ds_train, ds_test, info

"""## Creating the model"""

def create_model():
    # building the model
    model = Sequential()
    model.add(AveragePooling2D(6,3, input_shape=(300,300,3)))
    model.add(Conv2D(64, 3, activation='relu'))
    model.add(Conv2D(32, 3, activation='relu'))
    model.add(MaxPooling2D(2,2))
    model.add(Dropout(0.5))
    model.add(Flatten())
    model.add(Dense(128, activation='relu'))
    model.add(Dense(num_classes, activation='softmax'))
    # print the summary of the model architecture
    model.summary()
    # training the model using adam optimizer
    model.compile(loss="sparse_categorical_crossentropy", optimizer="adam", metrics=["accuracy"])
    return model

"""### Execute our stuff: load data, initiate model, train model"""

# load data
ds_train, ds_test, info = load_data()

# execute the create model function
model = create_model()

# callbacks
logdir = os.path.join("logs", "cifar10-model-v1")
tensorboard = TensorBoard(log_dir=logdir)

# create 'results' folder if it doesnt exist yet
if not os.path.isdir("results"):
    os.mkdir("results")

# training the model
model.fit(ds_train, epochs=epochs, validation_data=ds_test, verbose=1,
            steps_per_epoch=info.splits["train"].num_examples // batch_size,
            validation_steps=info.splits["test"].num_examples // batch_size,
            callbacks=[tensorboard])

# load data
# batch_size=-1 to get the full dataset in NumPy arrays from the returned tf.Tensor object
rock_paper_scissors_test = tfds.load(name="rock_paper_scissors", split=tfds.Split.TEST, batch_size=-1)

# tfds.as_numpy return a generator that yields NumPy array records out of a tf.data.Dataset
rock_paper_scissors_test = tfds.as_numpy(rock_paper_scissors_test)

# seperate the x and y
x_test, y_test = rock_paper_scissors_test["image"], rock_paper_scissors_test["label"]

# evaluate the model
model.evaluate(x_test, y_test)

model.save("RPStest.h5")

# rps classes
categories = {
    0: "rock",
    1: "paper",
    2: "scissors"
}

# load the model
loaded_model = load_model("RPStest.h5")

# evaluate the model
loaded_model.evaluate(x_test, y_test)

# predict an image
data_sample = next(iter(ds_test))
sample_image = data_sample[0].numpy()[0]
sample_label = categories[data_sample[1].numpy()[0]]
prediction = np.argmax(loaded_model.predict(sample_image.reshape(-1, *sample_image.shape))[0])
print("Predicted label:", categories[prediction])
print("True label:", sample_label)

# show the image
plt.axis('off')
plt.imshow(sample_image)
plt.show()

